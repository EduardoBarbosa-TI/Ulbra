ğŸ“˜ Projeto: Classe Matriz em Java

Este projeto implementa uma classe Matriz em Java, que permite criaÃ§Ã£o, manipulaÃ§Ã£o, exibiÃ§Ã£o e ordenaÃ§Ã£o de matrizes utilizando diferentes algoritmos de ordenaÃ§Ã£o (Bubble Sort e Quick Sort).

ğŸ“‘ DescriÃ§Ã£o da Classe Matriz
ğŸ”¹ Atributos

int[][] elementos â†’ armazena os valores da matriz.

int linhas â†’ nÃºmero de linhas.

int colunas â†’ nÃºmero de colunas.

ğŸ”¹ MÃ©todos principais

preencherManual() â†’ preenche a matriz com valores informados pelo usuÃ¡rio.

preencherAutomatico(int limiteMin, int limiteMax) â†’ preenche com valores aleatÃ³rios.

removerElemento(int linha, int coluna) â†’ zera o valor de uma posiÃ§Ã£o especÃ­fica.

exibirMatriz() â†’ imprime a matriz formatada.

ordenarPorLinhas(boolean usarQuickSort) â†’ ordena cada linha.

ordenarPorColunas(boolean usarQuickSort) â†’ ordena cada coluna.

ordenarMatrizCompleta(boolean usarQuickSort) â†’ ordena todos os elementos como vetor.

ğŸ”¹ MÃ©todos auxiliares de ordenaÃ§Ã£o

bubbleSort(int[] vetor)

quickSort(int[] vetor, int inicio, int fim)

particionar(int[] vetor, int inicio, int fim)


âš™ï¸ Funcionalidades Implementadas

Criar matriz com dimensÃµes personalizadas.

Preencher matriz manualmente ou automaticamente.

Exibir valores da matriz.

Remover elementos especÃ­ficos.

Ordenar matriz:

Por linhas

Por colunas

Matriz inteira

ğŸ”„ Algoritmos de OrdenaÃ§Ã£o
ğŸ”¹ Bubble Sort

Abordagem: iterativo e simples.

Complexidade:

Pior caso â†’ O(nÂ²)

Melhor caso â†’ O(n)

Mais eficiente em:

Matrizes pequenas.

Quando os dados jÃ¡ estÃ£o quase ordenados.

ğŸ”¹ Quick Sort

Abordagem: recursivo, divisÃ£o e conquista.

Complexidade:

Pior caso â†’ O(nÂ²)

Caso mÃ©dio/melhor caso â†’ O(n log n)

Mais eficiente em:

Matrizes grandes.

Dados desordenados de forma aleatÃ³ria.

ğŸ“Š ComparaÃ§Ã£o dos Algoritmos
Algoritmo	Abordagem	Complexidade MÃ©dia	Melhor uso
Bubble Sort	Iterativo	O(nÂ²)	Listas pequenas ou quase ordenadas
Quick Sort	Recursivo	O(n log n)	Listas grandes e desordenadas
ğŸ“ ConclusÃµes

Dificuldades:

Manipular colunas exigiu uso de vetores auxiliares.

Reconstruir a matriz apÃ³s ordenaÃ§Ã£o completa.

Aplicar recursÃ£o no Quick Sort.

Aprendizados:

NÃ£o faz sentido comparar um algoritmo iterativo como o Bubble Sort com um recursivo como o Quick Sort, pois a diferenÃ§a de desempenho entre eles Ã© extremamente significativa

Escolher algoritmos de acordo com o contexto.

Transformar matriz em vetor para aplicar ordenaÃ§Ã£o.

Entender recursÃ£o e divisÃ£o e conquista.

ReflexÃ£o:
O projeto reforÃ§a conceitos de POO, estruturas de dados e algoritmos de ordenaÃ§Ã£o, mostrando que nÃ£o hÃ¡ algoritmo universalmente melhor, mas sim o mais adequado para cada situaÃ§Ã£o e utilizar algoritmos recursivos entregarÃ£o muita performace que algoritmos iterativos.
